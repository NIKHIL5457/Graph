class Solution {
  public:
  int findpar(int u, vector<int> &par){
      if(u == par[u]) return u;
      return par[u] = findpar(par[u], par);
  }

  void unionbyrank(int u, int v, vector<int> &par, vector<int> &rank){
      int pu = findpar(u, par);
      int pv = findpar(v, par);
      if(pu == pv) return;
      if(rank[pu] > rank[pv]){
          par[pv] = pu;
      } else if(rank[pu] < rank[pv]){
          par[pu] = pv;
      } else {
          par[pv] = pu;
          rank[pu]++;
      }
  }

  int spanningTree(int V, vector<vector<int>>& edges) {
      // min-heap {weight, {u,v}}
      priority_queue<pair<int,pair<int,int>>, vector<pair<int,pair<int,int>>>, greater<pair<int,pair<int,int>>>> pq;

      // push all edges in priority_queue
      for(int i=0; i<edges.size(); i++){
          int u = edges[i][0];
          int v = edges[i][1];
          int w = edges[i][2];
          pq.push({w,{u,v}});
      }

      vector<int> par(V), rank(V,0);
      for(int i=0;i<V;i++) par[i]=i;

      int cost = 0, cnt = 0;

      // pick V-1 edges
      while(!pq.empty() && cnt < V-1){
          auto it = pq.top(); pq.pop();
          int wt = it.first;
          int u = it.second.first;
          int v = it.second.second;

          if(findpar(u, par) != findpar(v, par)){
              unionbyrank(u, v, par, rank);
              cost += wt;
              cnt++;
          }
      }
      return cost;
  }
};
